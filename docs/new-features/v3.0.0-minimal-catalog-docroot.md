# MCP v3.0.0: Minimal Catalog Output + Docroot Support

**Feature Branch**: `feature/v3.0.0-minimal-catalog-docroot`
**Target Version**: 3.0.0
**Status**: In Development
**Created**: October 25, 2025

---

## Overview

Redesign `get_repository_catalog` to minimize token usage and support docroot filtering, aligned with Claude Skills philosophy of minimal context.

**Key Goals**:
- Reduce catalog output size by 60-70%
- Support configurable docroot to limit scope
- Fix folder name doubling bug
- Improve tool discoverability

---

## Breaking Changes (v3.0.0)

### 1. Remove Hierarchical Tree (~50% size reduction)

**What's changing**:
- Delete `tree` property entirely from output
- Keep only flat file list (rename `flat_list` → `files`)
- Fixes folder name doubling bug as side effect

**Before**:
```json
{
  "tree": {
    ".claude": {
      ".claude": [...]  // ← Nested duplication
    }
  },
  "flat_list": [...]  // ← 100% duplicate data
}
```

**After**:
```json
{
  "files": [...]  // ← Single source of truth
}
```

---

### 2. Minimize File Entry Format (~30% additional reduction)

**Current format** (5 fields per file):
```json
{
  "path": "docs/policy.md",
  "name": "policy.md",           // ← Can derive from path
  "size": 784,
  "extension": ".md",            // ← Can derive from path
  "folder": "docs"               // ← Can derive from path
}
```

**New format** (2 fields per file):
```json
{
  "path": "docs/policy.md",
  "size": 784
}
```

**Client-side derivation**:
```javascript
const name = path.split('/').pop();
const extension = path.match(/\.[^.]+$/)?.[0] || '';
const folder = path.split('/').slice(0, -1).join('/') || '(root)';
```

---

### 3. Streamline Metadata

**Fields being removed**:
- `indexed_at` - Keep only `cache_expires_at` (more useful)
- `total_size_bytes` - Keep only human-readable `total_size`
- `scanned_path` - Redundant with new `docroot` field

**Current metadata**:
```json
{
  "repository": "owner/repo",
  "scanned_path": "(root)",
  "branch": "main",
  "indexed_at": "2025-10-25T01:47:11.526Z",
  "cache_expires_at": "2025-10-25T00:52:11.526Z",
  "statistics": {
    "total_files": 40,
    "total_folders": 15,
    "total_size_bytes": 235562,
    "total_size_human": "230.04 KB",
    "file_types": {".md": 40}
  }
}
```

**New metadata**:
```json
{
  "repository": "owner/repo",
  "branch": "main",
  "docroot": "docs",
  "cache_expires_at": "2025-10-25T00:52:11.526Z",
  "statistics": {
    "total_files": 40,
    "total_folders": 15,
    "total_size": "230 KB",
    "file_types": {".md": 40}
  },
  "files": [...]
}
```

---

## New Features

### 4. Docroot Configuration (Hybrid Approach)

**Docroot** = The root folder within a repository that contains the documents/assets you want to manage. Everything outside the docroot is ignored.

#### Configuration Levels

**Level 1: Server-level Default** (manifest.json user_config):
```json
"default_docroot": {
  "type": "string",
  "title": "Default Document Root",
  "description": "Default subfolder to scan for documents (e.g., 'docs'). Leave empty to scan entire repository.",
  "required": false,
  "sensitive": false
}
```

**Level 2: Per-repo Override** (.mcp-config.json in repo root):
```json
{
  "mcp": {
    "docroot": "docs",
    "include_extensions": [".md", ".txt", ".pdf"]
  }
}
```

**Level 3: Tool Parameter** (per-call override):
```javascript
get_repository_catalog({
  owner: "jack4git",
  repo: "my-docs",
  path: "documentation"  // ← Overrides all defaults
})
```

#### Priority Logic

When determining which docroot to use:

1. **Tool parameter `path`** (if provided) - Highest priority
2. **Repo `.mcp-config.json` docroot** (if exists)
3. **Server `default_docroot`** (if configured)
4. **Repository root** (fallback) - Lowest priority

#### Example Scenarios

**Scenario A: No configuration**
- Server default: (none)
- Repo config: (none)
- Tool param: (none)
- **Result**: Scans entire repository from root

**Scenario B: Server default only**
- Server default: `"docs"`
- Repo config: (none)
- Tool param: (none)
- **Result**: Scans `docs/` folder in all repos

**Scenario C: Repo override**
- Server default: `"docs"`
- Repo config: `"docroot": "documentation"`
- Tool param: (none)
- **Result**: Scans `documentation/` folder (repo config wins)

**Scenario D: Tool parameter override**
- Server default: `"docs"`
- Repo config: `"docroot": "documentation"`
- Tool param: `"path": "archive"`
- **Result**: Scans `archive/` folder (tool param wins)

---

### 5. Config File Caching

**Strategy**:
- Cache `.mcp-config.json` contents along with catalog
- 5-minute TTL (same as catalog)
- Single API call on first access
- Subsequent calls use cached config
- Cache key: `${owner}/${repo}/config`

**Benefits**:
- No extra API calls after first catalog request
- Config changes take effect after cache expires
- Can manually clear cache if needed

**Implementation**:
```javascript
async loadRepoConfig(owner, repo) {
  // Check cache first
  const cached = this.getCachedConfig(owner, repo);
  if (cached) return cached;

  try {
    // Fetch .mcp-config.json from repo root
    const config = await this.fetchConfigFile(owner, repo);
    this.setCachedConfig(owner, repo, config);
    return config;
  } catch (error) {
    // File doesn't exist - cache empty config
    const emptyConfig = { docroot: null, include_extensions: null };
    this.setCachedConfig(owner, repo, emptyConfig);
    return emptyConfig;
  }
}
```

---

## Implementation Steps

### Step 1: Update `document-catalog-service.cjs`

**File**: `src/services/document-catalog-service.cjs`

#### Changes Required

**1.1 Add config loading method**:
```javascript
/**
 * Load repository configuration from .mcp-config.json
 * @param {string} owner - Repository owner
 * @param {string} repo - Repository name
 * @returns {Promise<Object>} - Config object or defaults
 */
async loadRepoConfig(owner, repo) {
  const cacheKey = `${owner}/${repo}/config`;
  const cached = this.cache.get(cacheKey);

  if (cached && (Date.now() - cached.timestamp) < this.TTL) {
    return cached.config;
  }

  try {
    const endpoint = `/repos/${owner}/${repo}/contents/.mcp-config.json`;
    const response = await this.api.makeGitHubRequest(endpoint);

    // Decode base64 content
    const content = Buffer.from(response.content, 'base64').toString('utf-8');
    const config = JSON.parse(content);

    const repoConfig = {
      docroot: config.mcp?.docroot || null,
      include_extensions: config.mcp?.include_extensions || null
    };

    this.cache.set(cacheKey, {
      config: repoConfig,
      timestamp: Date.now()
    });

    return repoConfig;
  } catch (error) {
    // Config file doesn't exist - cache empty config
    const emptyConfig = { docroot: null, include_extensions: null };
    this.cache.set(cacheKey, {
      config: emptyConfig,
      timestamp: Date.now()
    });
    return emptyConfig;
  }
}
```

**1.2 Update `buildCatalog()` signature**:
```javascript
/**
 * Build catalog of all documents in repository
 * @param {string} owner - Repository owner
 * @param {string} repo - Repository name
 * @param {Object} options - Catalog options
 * @param {string} options.path - Root path to catalog (optional)
 * @param {string[]} options.extensions - File extensions to include (optional)
 * @param {string} options.branch - Branch name (optional, default: main/master)
 * @param {string} options.serverDocroot - Server-level default docroot (optional)
 * @returns {Promise<Object>} - Document catalog
 */
async buildCatalog(owner, repo, options = {}) {
  // Check cache first
  const effectivePath = await this.resolveDocroot(owner, repo, options);
  const cached = this.getCachedCatalog(owner, repo, effectivePath);
  if (cached) {
    return cached;
  }

  // Load repo config
  const repoConfig = await this.loadRepoConfig(owner, repo);

  // Determine final docroot and extensions
  const docroot = effectivePath;
  const extensions = options.extensions || repoConfig.include_extensions || ['.md', '.txt'];
  const branch = options.branch || 'main';

  try {
    // ... rest of existing logic
  } catch (error) {
    // ... error handling
  }
}
```

**1.3 Add docroot resolution method**:
```javascript
/**
 * Resolve effective docroot from priority hierarchy
 * @param {string} owner - Repository owner
 * @param {string} repo - Repository name
 * @param {Object} options - Options object
 * @returns {Promise<string>} - Effective docroot path
 */
async resolveDocroot(owner, repo, options) {
  // Priority 1: Tool parameter
  if (options.path) return options.path;

  // Priority 2: Repo config
  const repoConfig = await this.loadRepoConfig(owner, repo);
  if (repoConfig.docroot) return repoConfig.docroot;

  // Priority 3: Server default
  if (options.serverDocroot) return options.serverDocroot;

  // Priority 4: Repository root
  return '';
}
```

**1.4 Remove `buildTreeStructure()` method entirely**

Delete lines 119-177 (the entire method).

**1.5 Simplify `buildFlatList()` method**:
```javascript
/**
 * Build flat list from file array (minimal format)
 * @private
 */
buildFlatList(files) {
  return files.map(file => ({
    path: file.path,
    size: file.size
  })).sort((a, b) => a.path.localeCompare(b.path));
}
```

**1.6 Update `calculateStatistics()` method**:
```javascript
/**
 * Calculate statistics for catalog
 * @private
 */
calculateStatistics(files, extensions) {
  const stats = {
    total_files: files.length,
    total_folders: new Set(files.map(f => {
      const parts = f.path.split('/');
      return parts.length > 1 ? parts.slice(0, -1).join('/') : '(root)';
    })).size,
    total_size: this.formatBytes(files.reduce((sum, f) => sum + (f.size || 0), 0)),
    file_types: {}
  };

  // Count by extension
  extensions.forEach(ext => {
    const count = files.filter(f => f.extension === ext).length;
    if (count > 0) {
      stats.file_types[ext] = count;
    }
  });

  return stats;
}
```

**1.7 Update catalog output structure**:
```javascript
// Build final catalog (in buildCatalog method)
const catalog = {
  repository: `${owner}/${repo}`,
  branch: treeBranch,
  docroot: docroot || '(root)',
  cache_expires_at: new Date(Date.now() + this.TTL).toISOString(),
  statistics,
  files: flatList  // ← renamed from flat_list
};
```

**1.8 Update constructor to accept server config**:
```javascript
constructor(githubApiService, serverConfig = {}) {
  this.api = githubApiService;
  this.serverConfig = serverConfig;
  this.cache = new Map();
  this.TTL = 5 * 60 * 1000;
}
```

---

### Step 2: Update `document-catalog-minimal.cjs`

**File**: `src/handlers/document-catalog-minimal.cjs`

#### Changes Required

**2.1 Update function signature**:
```javascript
async function getRepositoryCatalogHandler(params, defaultRepo, apiService, serverConfig = {}) {
```

**2.2 Update parameter handling**:
```javascript
try {
  // Extract parameters
  const owner = params.owner || defaultRepo.owner;
  const repo = params.repo || defaultRepo.repo;

  // Validate required parameters
  if (!owner || !repo) {
    return {
      success: false,
      error: 'Repository owner and name are required. Please specify owner and repo, or configure defaults.'
    };
  }

  // Build options object
  const options = {
    path: params.path || null,  // Tool parameter (highest priority)
    extensions: params.include_extensions || null,
    branch: params.branch || 'main',
    serverDocroot: serverConfig.default_docroot || null  // Server default (lowest priority)
  };

  // Create catalog service instance
  const catalogService = new DocumentCatalogService(apiService, serverConfig);

  // Build catalog (will use cache if available)
  const catalog = await catalogService.buildCatalog(owner, repo, options);

  // Return success response
  return {
    success: true,
    data: catalog,
    message: `Found ${catalog.statistics.total_files} documents across ${catalog.statistics.total_folders} folders`
  };

} catch (error) {
  // Handle errors gracefully
  return {
    success: false,
    error: `Failed to build repository catalog: ${error.message}`,
    details: error.stack
  };
}
```

---

### Step 3: Update `manifest.json`

**File**: `manifest.json`

#### Changes Required

**3.1 Bump version to 3.0.0**:
```json
"version": "3.0.0"
```

**3.2 Add default_docroot to user_config**:
```json
"user_config": {
  "github_client_id": { ... },
  "github_client_secret": { ... },
  "default_owner": { ... },
  "default_repo": { ... },
  "default_docroot": {
    "type": "string",
    "title": "Default Document Root",
    "description": "Default subfolder to scan for documents (e.g., 'docs'). Leave empty to scan entire repository.",
    "required": false,
    "sensitive": false
  }
}
```

**3.3 Update server args**:
```json
"mcp_config": {
  "command": "node",
  "args": [
    "${__dirname}/server.cjs",
    "--default-owner",
    "${user_config.default_owner}",
    "--default-repo",
    "${user_config.default_repo}",
    "--default-docroot",
    "${user_config.default_docroot}"
  ],
  "env": {
    "GITHUB_CLIENT_ID": "${user_config.github_client_id}",
    "GITHUB_CLIENT_SECRET": "${user_config.github_client_secret}"
  }
}
```

**3.4 Reorder tools array - Move catalog to FIRST position**:
```json
"tools": [
  {
    "name": "get_repository_catalog",
    "description": "Get minimal catalog of repository documents. Respects docroot configuration to limit scope. Returns flat file list only (no tree structure)."
  },
  {
    "name": "create_or_update_file",
    "description": "Create or update a file in the GitHub repository"
  },
  {
    "name": "get_file",
    "description": "Get the contents of a file from the repository"
  },
  {
    "name": "list_contents",
    "description": "List the contents of a directory in the repository"
  },
  {
    "name": "delete_file",
    "description": "Delete a file from the repository"
  },
  {
    "name": "search_code",
    "description": "Search for code across the repository"
  },
  {
    "name": "list_commits",
    "description": "List commit history for the repository or a specific file"
  }
]
```

**Rationale for reordering**:
- Catalog is the discovery/orientation tool
- Users typically call it first to understand repository structure
- Reduces cognitive load - most important tool appears first
- Follows principle of "most frequently used first"

---

### Step 4: Update `server.cjs`

**File**: `server.cjs`

#### Changes Required

**4.1 Parse --default-docroot argument**:
```javascript
// Parse command line arguments
const args = {};
for (let i = 2; i < process.argv.length; i += 2) {
  const key = process.argv[i];
  const value = process.argv[i + 1];
  args[key] = value;
}

const defaultOwner = args['--default-owner'] || '';
const defaultRepo = args['--default-repo'] || '';
const defaultDocroot = args['--default-docroot'] || '';  // ← Add this
```

**4.2 Create server config object**:
```javascript
// Build server configuration
const serverConfig = {
  default_docroot: defaultDocroot
};
```

**4.3 Pass serverConfig to catalog handler**:
```javascript
// In tool handler switch statement
case 'get_repository_catalog':
  result = await getRepositoryCatalogHandler(
    toolCall.params,
    { owner: defaultOwner, repo: defaultRepo },
    githubApi,
    serverConfig  // ← Add this parameter
  );
  break;
```

---

### Step 5: Create Migration Guide

**File**: `docs/migration/v2-to-v3.md`

Create comprehensive migration documentation covering:
- Breaking changes summary
- Output format changes
- Code migration examples
- Docroot configuration guide
- FAQ

(Full content will be created in separate file)

---

### Step 6: Update README.md

**File**: `README.md`

#### Changes Required

**6.1 Update version references**:
- Change version from 2.1.0 to 3.0.0
- Add "Breaking Changes in v3.0.0" section

**6.2 Add docroot configuration section**:
```markdown
### Docroot Configuration (v3.0+)

Limit catalog scope to a specific subfolder:

**Server-level default** (for all repositories):
Configure `default_docroot` when setting up the MCP.

**Per-repository override** (in repository):
Create `.mcp-config.json` in repository root:

\```json
{
  "mcp": {
    "docroot": "docs",
    "include_extensions": [".md", ".txt", ".pdf"]
  }
}
\```
```

**6.3 Update catalog output examples**:
Show new minimal format instead of old format.

---

### Step 7: Create Config File Specification

**File**: `docs/config/mcp-config-spec.md`

Document the `.mcp-config.json` file format:
- Schema specification
- Field descriptions
- Examples
- Validation rules

(Full content will be created in separate file)

---

## Testing Plan

### Test Suite Updates

**File**: `tests/test-catalog.js` (create if doesn't exist)

#### Test Cases

**1. Baseline Tests (no docroot)**:
```javascript
describe('Catalog without docroot', () => {
  it('should scan entire repository when no docroot configured', async () => {
    const catalog = await catalogService.buildCatalog('owner', 'repo', {});
    expect(catalog.docroot).toBe('(root)');
    expect(catalog.files.length).toBeGreaterThan(0);
  });

  it('should return minimal file format (path + size only)', async () => {
    const catalog = await catalogService.buildCatalog('owner', 'repo', {});
    catalog.files.forEach(file => {
      expect(file).toHaveProperty('path');
      expect(file).toHaveProperty('size');
      expect(file).not.toHaveProperty('name');
      expect(file).not.toHaveProperty('extension');
      expect(file).not.toHaveProperty('folder');
    });
  });
});
```

**2. Server-level Docroot Tests**:
```javascript
describe('Server-level docroot', () => {
  it('should use server default_docroot when configured', async () => {
    const options = { serverDocroot: 'docs' };
    const catalog = await catalogService.buildCatalog('owner', 'repo', options);
    expect(catalog.docroot).toBe('docs');
    catalog.files.forEach(file => {
      expect(file.path).toMatch(/^docs\//);
    });
  });
});
```

**3. Repo Config Override Tests**:
```javascript
describe('Repo .mcp-config.json override', () => {
  it('should load and use repo config docroot', async () => {
    // Mock .mcp-config.json existence
    mockConfigFile({ docroot: 'documentation', include_extensions: ['.md'] });

    const catalog = await catalogService.buildCatalog('owner', 'repo', {});
    expect(catalog.docroot).toBe('documentation');
  });

  it('should prefer repo config over server default', async () => {
    mockConfigFile({ docroot: 'documentation' });
    const options = { serverDocroot: 'docs' };

    const catalog = await catalogService.buildCatalog('owner', 'repo', options);
    expect(catalog.docroot).toBe('documentation');  // Repo wins
  });
});
```

**4. Tool Parameter Override Tests**:
```javascript
describe('Tool parameter override', () => {
  it('should use tool path parameter over all defaults', async () => {
    mockConfigFile({ docroot: 'documentation' });
    const options = {
      path: 'archive',
      serverDocroot: 'docs'
    };

    const catalog = await catalogService.buildCatalog('owner', 'repo', options);
    expect(catalog.docroot).toBe('archive');  // Tool param wins
  });
});
```

**5. Config Caching Tests**:
```javascript
describe('Config file caching', () => {
  it('should cache repo config for TTL duration', async () => {
    const spy = jest.spyOn(githubApi, 'makeGitHubRequest');

    // First call - should fetch config
    await catalogService.buildCatalog('owner', 'repo', {});
    expect(spy).toHaveBeenCalledWith(expect.stringContaining('.mcp-config.json'));

    spy.mockClear();

    // Second call within TTL - should use cache
    await catalogService.buildCatalog('owner', 'repo', {});
    expect(spy).not.toHaveBeenCalledWith(expect.stringContaining('.mcp-config.json'));
  });

  it('should refetch config after cache expires', async () => {
    jest.useFakeTimers();

    await catalogService.buildCatalog('owner', 'repo', {});

    // Advance time beyond TTL (5 minutes)
    jest.advanceTimersByTime(6 * 60 * 1000);

    const spy = jest.spyOn(githubApi, 'makeGitHubRequest');
    await catalogService.buildCatalog('owner', 'repo', {});

    expect(spy).toHaveBeenCalledWith(expect.stringContaining('.mcp-config.json'));

    jest.useRealTimers();
  });
});
```

**6. Output Format Tests**:
```javascript
describe('Output format validation', () => {
  it('should not include tree property', async () => {
    const catalog = await catalogService.buildCatalog('owner', 'repo', {});
    expect(catalog).not.toHaveProperty('tree');
  });

  it('should include files property (not flat_list)', async () => {
    const catalog = await catalogService.buildCatalog('owner', 'repo', {});
    expect(catalog).toHaveProperty('files');
    expect(catalog).not.toHaveProperty('flat_list');
  });

  it('should not include indexed_at', async () => {
    const catalog = await catalogService.buildCatalog('owner', 'repo', {});
    expect(catalog).not.toHaveProperty('indexed_at');
  });

  it('should include cache_expires_at', async () => {
    const catalog = await catalogService.buildCatalog('owner', 'repo', {});
    expect(catalog).toHaveProperty('cache_expires_at');
  });

  it('should have total_size (not total_size_bytes)', async () => {
    const catalog = await catalogService.buildCatalog('owner', 'repo', {});
    expect(catalog.statistics).toHaveProperty('total_size');
    expect(catalog.statistics).not.toHaveProperty('total_size_bytes');
    expect(catalog.statistics).not.toHaveProperty('total_size_human');
  });
});
```

### Integration Tests

**7. End-to-end Catalog Tests**:
```javascript
describe('Full catalog workflow', () => {
  it('should build complete catalog with docroot', async () => {
    const catalog = await buildFullCatalog('jack4git', 'ai-first-docs-01', {
      serverDocroot: 'docs'
    });

    expect(catalog.repository).toBe('jack4git/ai-first-docs-01');
    expect(catalog.docroot).toBe('docs');
    expect(catalog.files.length).toBeGreaterThan(0);
    expect(catalog.statistics.total_files).toBe(catalog.files.length);
  });
});
```

### Performance Tests

**8. Size Reduction Verification**:
```javascript
describe('Output size validation', () => {
  it('should reduce output size by at least 60% vs v2', async () => {
    const v3Catalog = await buildCatalog('owner', 'repo', {});
    const v3Size = JSON.stringify(v3Catalog).length;

    const v2Catalog = await buildV2Catalog('owner', 'repo', {});  // Old format
    const v2Size = JSON.stringify(v2Catalog).length;

    const reduction = ((v2Size - v3Size) / v2Size) * 100;
    expect(reduction).toBeGreaterThanOrEqual(60);
  });
});
```

---

## Expected Results

### Size Reduction Analysis

**Example: 40-file repository**

**Current v2.1.0 output** (~30 KB):
```json
{
  "repository": "owner/repo",
  "scanned_path": "(root)",
  "branch": "main",
  "indexed_at": "2025-10-25T01:47:11.526Z",
  "cache_expires_at": "2025-10-25T00:52:11.526Z",
  "statistics": {
    "total_files": 40,
    "total_folders": 15,
    "total_size_bytes": 235562,
    "total_size_human": "230.04 KB",
    "file_types": {".md": 40}
  },
  "tree": { /* ~15 KB of nested objects */ },
  "flat_list": [ /* ~15 KB of file entries with 5 fields each */ ]
}
```

**New v3.0.0 output** (~10 KB):
```json
{
  "repository": "owner/repo",
  "branch": "main",
  "docroot": "(root)",
  "cache_expires_at": "2025-10-25T00:52:11.526Z",
  "statistics": {
    "total_files": 40,
    "total_folders": 15,
    "total_size": "230 KB",
    "file_types": {".md": 40}
  },
  "files": [ /* ~5 KB of file entries with 2 fields each */ ]
}
```

**Savings Breakdown**:
- Removed `tree`: -15 KB (50%)
- Simplified file entries: -10 KB (33%)
- Streamlined metadata: -5 KB (17%)
- **Total reduction: ~67%**

### Token Usage Comparison

**40-file repository**:
- **Current**: ~8,000 tokens
- **New**: ~2,500 tokens
- **Savings**: ~5,500 tokens per catalog call

**200-file repository**:
- **Current**: ~40,000 tokens
- **New**: ~12,500 tokens
- **Savings**: ~27,500 tokens per catalog call

### Performance Impact

**API Calls**:
- First catalog call: 2 calls (tree + config file)
- Subsequent calls: 0 calls (cached for 5 minutes)

**Latency**:
- Config file fetch: ~200ms (first call only)
- Overall impact: Negligible (<5% increase on first call, no impact after)

---

## Migration Path for Consumers

### Repository Browser JSX

**Current code** (v2.1.0):
```javascript
const CATALOG_DATA = {
  flat_list: [
    {
      path: "docs/policy.md",
      name: "policy.md",
      size: 784,
      extension: ".md",
      folder: "docs"
    }
  ]
};

// Use flat_list
const files = CATALOG_DATA.flat_list;
```

**Updated code** (v3.0.0):
```javascript
const CATALOG_DATA = {
  files: [
    {
      path: "docs/policy.md",
      size: 784
    }
  ]
};

// Use files (renamed)
const files = CATALOG_DATA.files.map(file => ({
  ...file,
  name: file.path.split('/').pop(),
  extension: file.path.match(/\.[^.]+$/)?.[0] || '',
  folder: file.path.split('/').slice(0, -1).join('/') || '(root)'
}));
```

### Other Consumers

Any code that uses the catalog output needs to:

1. **Change property name**: `flat_list` → `files`
2. **Derive filename**: `name = path.split('/').pop()`
3. **Derive extension**: `extension = path.match(/\.[^.]+$/)?.[0] || ''`
4. **Derive folder**: `folder = path.split('/').slice(0, -1).join('/') || '(root)'`
5. **Remove tree usage**: No `tree` property available

---

## File Changes Summary

### Modified Files

1. **`src/services/document-catalog-service.cjs`** (major refactor)
   - Add `loadRepoConfig()` method
   - Add `resolveDocroot()` method
   - Update `buildCatalog()` signature and logic
   - Remove `buildTreeStructure()` method
   - Simplify `buildFlatList()` method
   - Update `calculateStatistics()` method
   - Update catalog output structure
   - Update constructor to accept server config

2. **`src/handlers/document-catalog-minimal.cjs`** (parameter handling)
   - Update function signature to accept `serverConfig`
   - Update parameter extraction and priority logic
   - Pass options to catalog service

3. **`manifest.json`** (version, config, tool ordering)
   - Bump version to 3.0.0
   - Add `default_docroot` user config
   - Update server args to include `--default-docroot`
   - Reorder tools array (catalog first)
   - Update catalog tool description

4. **`server.cjs`** (argument parsing)
   - Parse `--default-docroot` argument
   - Create `serverConfig` object
   - Pass `serverConfig` to catalog handler

5. **`README.md`** (documentation)
   - Update version references
   - Add breaking changes section
   - Add docroot configuration guide
   - Update catalog output examples

6. **`package.json`** (version bump)
   - Update version to 3.0.0

### New Files

1. **`docs/new-features/v3.0.0-minimal-catalog-docroot.md`** (this file)
   - Complete implementation plan

2. **`docs/migration/v2-to-v3.md`**
   - Breaking changes summary
   - Migration guide for consumers
   - Code examples

3. **`docs/config/mcp-config-spec.md`**
   - `.mcp-config.json` specification
   - Field descriptions
   - Validation rules
   - Examples

4. **`docs/config/mcp-config-example.json`**
   - Example config file

### Test Files

1. **`tests/test-catalog.js`** (create or update)
   - All test cases from Testing Plan section

---

## Implementation Checklist

### Phase 1: Core Changes

- [ ] Update `document-catalog-service.cjs`
  - [ ] Add `loadRepoConfig()` method
  - [ ] Add `resolveDocroot()` method
  - [ ] Update `buildCatalog()` method
  - [ ] Remove `buildTreeStructure()` method
  - [ ] Simplify `buildFlatList()` method
  - [ ] Update `calculateStatistics()` method
  - [ ] Update catalog output structure
  - [ ] Update constructor

- [ ] Update `document-catalog-minimal.cjs`
  - [ ] Update function signature
  - [ ] Update parameter handling
  - [ ] Pass server config to service

- [ ] Update `manifest.json`
  - [ ] Bump version to 3.0.0
  - [ ] Add `default_docroot` config
  - [ ] Update server args
  - [ ] Reorder tools array
  - [ ] Update tool description

- [ ] Update `server.cjs`
  - [ ] Parse `--default-docroot` argument
  - [ ] Create server config object
  - [ ] Pass config to handler

### Phase 2: Documentation

- [ ] Create `docs/migration/v2-to-v3.md`
- [ ] Create `docs/config/mcp-config-spec.md`
- [ ] Create `docs/config/mcp-config-example.json`
- [ ] Update `README.md`
  - [ ] Version references
  - [ ] Breaking changes section
  - [ ] Docroot configuration guide
  - [ ] Output examples

### Phase 3: Testing

- [ ] Create/update `tests/test-catalog.js`
- [ ] Run all existing tests (ensure they still pass)
- [ ] Run new v3 tests
- [ ] Measure output size reduction
- [ ] Test with real repositories

### Phase 4: Build & Release

- [ ] Update `package.json` version
- [ ] Build `.mcpb` package
- [ ] Test installation
- [ ] Create GitHub release
- [ ] Publish to registry (if applicable)

---

## Rollback Plan

If issues are discovered after release:

1. **Immediate**: Revert to v2.1.0 by checking out previous commit
2. **Short-term**: Create v3.0.1 patch with fixes
3. **Long-term**: If fundamental design issues, create v3.1.0 with revised approach

**Git strategy**:
```bash
# Revert to v2.1.0
git checkout tags/v2.1.0 -b hotfix/revert-v3

# Or cherry-pick fixes
git checkout main
git revert <commit-hash>
git commit -m "Revert v3.0.0 changes"
```

---

## Questions & Decisions Log

**Q: Should we remove `sha` field from file entries?**
**A**: Yes - not needed for document management use case. Can always fetch from GitHub API if needed.

**Q: Should docroot apply to write operations too?**
**A**: No, not initially. Start with catalog only. Can expand in v3.1.0 if needed.

**Q: Cache TTL for config file - same as catalog (5min) or different?**
**A**: Same as catalog for simplicity. They're fetched together anyway.

**Q: Should we validate `.mcp-config.json` format?**
**A**: Yes, but gracefully - if invalid JSON, treat as if file doesn't exist.

**Q: What if repo has both old-style `path` param usage and new `.mcp-config.json`?**
**A**: Tool param wins (highest priority). Document this clearly.

---

## Success Criteria

### Must Have (v3.0.0 release)

- ✅ Catalog output reduced by ≥60%
- ✅ Folder name doubling bug fixed
- ✅ Docroot configuration works (server + repo levels)
- ✅ Config file caching implemented
- ✅ All tests pass
- ✅ Migration guide complete
- ✅ No regressions in existing functionality

### Nice to Have (future versions)

- [ ] Docroot for write operations (v3.1.0)
- [ ] Config file validation with JSON schema
- [ ] Admin tool to view/clear cache
- [ ] Performance metrics logging

---

## Timeline Estimate

**Phase 1 (Core Changes)**: 4-6 hours
**Phase 2 (Documentation)**: 2-3 hours
**Phase 3 (Testing)**: 2-4 hours
**Phase 4 (Build & Release)**: 1-2 hours

**Total**: 9-15 hours

---

## Related Issues

- **Catalog duplication**: [docs/fixes/repository-catalog-duplication-analysis.md](../fixes/repository-catalog-duplication-analysis.md)
- **Browser mismatch**: [github-business-docs-by-claude/docs/fixes/repository-browser-data-mismatch.md](../../../claude/claude-skills/github-business-docs-by-claude/docs/fixes/repository-browser-data-mismatch.md)

---

**Status**: Ready for implementation
**Next Steps**: Begin Phase 1 - Core Changes
